# 내용 정리

## 3. 고급 타입

### 3.1

### any 타입

- 타입스크립트에서 any 타입을 어쩔 수 없이 사용해야 할 때가 있는데 대표적으로 아래 3가지.
  1. 개발 단계에서 임시로 값을 지정해야 할 때
  2. 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때
  3. 값을 예측할 수 없을 때 암묵적으로 사용

### unknown 타입

- any를 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값을 할당할 수 없다.

### never 타입

- 값을 반환할 수 없는 타입을 말한다.
- 자바스크립트에서 값을 반환할 수 없는 때는 대표적으로 아래 2가지.
  1. 에러를 던지는 경우
  2. 무한히 함수가 실행되는 경우

### Array 타입

- 타입스크립트에서는 일반적으로 배열의 크기까지 제한하지는 않지만 정적 타입의 특성을 살려 명시적인 타입을 선언하여 해당 타입의 원소를 관리하는 것을 강제한다.
- 튜플은 배열 타입의 하위 타입으로 기존 타입스크립트의 배열 기능에 길이 제한까지 추가한 타입 시스템이라고 볼 수 있다.

### enum 타입

- 열거형 타입으로 얻을 수 있는 효과는 1) 타입 안정성, 2) 명확한 의미 전달과 높은 응집력, 3) 가독성이다.
- 관련이 높은 멤버를 모아 문자열 상수처럼 사용하고자 할 때 유용하게 쓸 수 있다.
- 사용 시 주의할 점
  - 숫자로만 이루어져 있거나 타입스크립트가 자동으로 추론한 열거형은 안전하지 않은 결과를 낳을 수 있다.
    - 이러한 동작을 막기 위해 `const enum`으로 열거형을 선언하는 방법이 있다.
  - 문자열 상수 방식으로 열거형을 사용하는 것이 숫자 상수 방식보다 더 안전하여 의도하지 않은 값의 할당이나 접근을 방지하는 데 도움이 된다.

### 3.2 타입 조합

### 교차 타입

- 기존에 존재하는 다른 타입들을 합쳐서 해당 타입의 모든 멤버를 가지는 새로운 타입을 생성하는 것이다.

### 맵드 타입

- 맵드 타입은 다른 타입을 기반으로 한 타입을 선언할 때 사용하는 문법인데, 인덱스 시그니처 문법을 사용해서 반복적인 타입 선언을 효과적으로 줄일 수 있다.

### 제네릭

- 다양한 타입 간에 재사용성을 높이기 위해 사용하는 문법
- 변수명으로 T(Type), E(Element), K(Key), V(Value) 등 한 글자로 된 이름을 많이 사용한다.

### 호출 시그니처의 제네릭

- 호출 시그니저는 타입스크립트의 함수 타입 문법으로 함수의 매개변수와 반환 타입을 미리 선언하는 것을 말한다.

## 4. 타입 확장하기 • 좁히기

### 4.1 타입 확장하기

- 장점: 코드 중복을 줄일 수 있다.

- 유니온 타입: 합집합
- 교차 타입: 교집합

- 타입스크립트의 타입을 속성의 집합이 아니라 값의 집합으로 이해해야 한다.
- 아래 코드에서 DeliveryTip과 StarRating은 공통된 속성이 없는데도 Filter의 타입은 공집합(=never 타입)이 아닌 두 속성을 모두 포함한 타입이 된다.

  - 왜냐하면 타입 속성의 집합이 아닌 값의 집합으로 해석되기 때문이다.
  - 즉, 교차 타입 Filter는 DeliveryTip의 tip 속성과 StarRating의 rate 속성을 모두 만족하는 값

  ```typescript
  /* 배달 팁 */
  interface DeliveryTip {
    tip: string;
  }

  /* 별점 */
  interface StarRating {
    rate: number;
  }

  type Filter = DeliveryTip & StarRating;

  const filter: Filter = {
    tip: '1000원 이하',
    rate: 4,
  };
  ```

- 교차 타입을 사용할 때 타입이 서로 호환되지 않는 경우도 있다.
- 아래 코드에서 Universal 타입은 두 타입을 모두 만족하는 경우에만 유지된다.

```typescript
type IdType = string | number;
type Numeric = number | boolean;

type Universal = IdType & Numeric;
```

- 경우의 수 4가지.

  1. string이면서 number인 경우
  2. string이면서 boolean 경우
  3. number이면서 number인 경우 -> ⭐️ 이게 두 타입을 모두 만족하는 경우 ⭐️
  4. number이면서 boolean인 경우

  - 즉, Universal의 타입은 number가 된다.

- 유니온 타입과 교차 타입을 사용한 새로운 타입은 오직 type 키워드로만 선언할 수 있다.

### 4.2 타입 좁히기

- 특정 문맥 안에서 타입스크립트가 해당 변수를 타입 A로 추론하도록 유도하면서 런타임에도 유효한 방법이 필요하다. 이때 사용하는 것이 바로 **타입 가드**이다.
- 타입 가드는 크게 자바스크립트 연산자를 활용한 타입 가드와 사용자 정의 타입 가드로 구분할 수 있다.

  1. 자바스크립트 연산자를 활용한 타입 가드는 typeof, instanceof, in과 같은 연산자를 사용해서 제어문으로 특정 타입 값을 가질 수밖에 없는 상황을 유도하여 타입을 좁히는 방식이다. 자바스크립트 연산자를 사용하는 이유는 런타임에 유효한 타입 가드를 만들기 위해서다.
  2. 사용자 정의 타입 가드는 사용자가 직접 어떤 타입으로 값을 좁힐지를 직접 정하는 방식이다.

### typeof 연산자

- 사용 시, 원시타입에 대해 추론할 수 있다.
- 자바스크립트의 동장 방식으로 인해 null과 배열 타입 등이 object 타입으로 판별되는 등 복잡한 타입을 검증하기에는 한계가 있다.
- 따라서 타입 연산자는 주로 원시 타입을 좁히는 용도로만 사용할 것을 권장한다.

### instanceof 연산자

- 사용 시, 인스턴스화된 객체의 타입을 판별하는 타입 가드로 사용할 수 있다.
- `A instanceof B` = `타입_검사할_대상_변수 instanceof 특정_객체의_생성자`
- A의 프로토타입 체인에 생성자 B가 존재하는지 검사 -> 존재하면 true, 없으면 false 반환
- 이러한 동작 방식으로 인해 A의 프로토타입 속성 변화에 따라 instanceof 연산자의 결과가 달라질 수 있다는 점은 유의해야 한다.

### in 연산자

- 사용 시, 객체에 속성이 있는지 확인한 다음에 true/false를 반환한다.
- 프로토타입 체인으로 접근할 수 있다면 전부 true를 반환한다.
- delete 연산자를 사용하여 객체 내부에서 해당 속성을 제거해야만 false를 반환한다.
- 자바스크립트에서: 런타임의 값을 검사
- 타입스크립트에서: 객체 타입에 속성이 존재하는지를 검사

### is 연산자

- `A is B` = `매개변수 is 타입`
- 타입스크립트에게 반환 값에 대한 타입 정보를 알려주고 싶을 때 is를 사용할 수 있다.

### 식별할 수 있는 유니온

- 각 타입이 비슷한 구조를 가지지만 서로 호환되지 않도록 만들어주기 위해서는 타입들이 서로 포함관계를 가지지 않도록 정의해야 한다. 바로 이 때 식별할 수 있는 유니온을 활용한다.
- 식별할 수 있는 유니온이란 타입 간의 구조 호환을 막기 위해 타입마다 구분할 수 있는 판별자를 달아주어 포함관계를 제거하는 것이다.

```typescript
type TextError = {
  errorType: 'TEXT'; // 식별할 수 있는 유니온의 판별자
  errorCode: string;
  errorMessage: string;
};
type ToastError = {
  errorType: 'TOAST'; // 식별할 수 있는 유니온의 판별자
  errorCode: string;
  errorMessage: string;
};
type AlertError = {
  errorType: 'ALERT'; // 식별할 수 있는 유니온의 판별자
  errorCode: string;
  errorMessage: string;
};
```

- 식별할 수 있는 유니온의 판별자는 유닛 타입으로 선언되어야 정상 동작한다.
- 유닛 타입은 다른 타입으로 쪼개지지 않고 오직 하나의 정확한 값을 가지는 타입을 말한다.
  - null, undefined, true, 1 (O)
  - void, string, number (X)

## 5. 타입 활용하기

### infer를 활용해서 타입 추론하기

```typescript
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
```

- UnpackPromise 타입은 제네릭으로 T를 받아 T가 Promise로 래핑된 경우라면 K를 반환하고, 그렇지 않은 경우에는 any를 반환한다.
- `Promise<infer K>`는 Promise의 반환 값을 추론해 해당 값의 타입을 K로 한다는 의미이다.

### Props의 타입, styled-components 타입의 중복 선언 줄이기

- Pick과 Omit 같은 유틸리티 타입으로 개선할 수 있다.
- 상속받는 컴포넌트 혹은 부모 컴포넌트에서 자식 컴포넌트로 넘겨주는 props 등에도 활용할 수 있다.

## 6. 타입스크립트 컴파일

- 타입스크립트 컴파일러의 동작 원리

  1. 타입스크립트 소스코드를 타입스크립트 AST로 만든다.(tsc)
  2. 타입 검사기가 AST를 확인하여 타입을 확인한다.(tsc)
  3. 타입스크립트 AST를 자바스크립트 소스로 변환한다.(tsc)
  4. 자바스크립트 소스코드를 자바스크립트 AST로 만든다.(런타임)
  5. AST가 바이트 코드로 변환된다.(런타임)
  6. 런타임에서 바이트 코드가 평가되어 프로그램이 실행된다.(런타임)

- 타입스크립트 컴파일러는 타입 검사를 수행한 후 코드 변환을 시작하는데, 이때 타입오류가 있더라도 일단 컴파일을 진행한다.

  - 타입스크립트 코드가 자바스크립트 코드로 변환되는 과정은 타입 검사와 독립적으로 동작하기 때문이다.
  - 타입스크립트 코드의 타이핑이 잘못되어 발생하는 에러는 자바스크립트 실행 과정에서 런타임 에러로 처리된다.

- 타입스크립트 컴파일러의 역할

  1. 최신 버전의 타스/자스 코드를 구버전의 자바스크립트로 트랜스파일한다.
  2. 코드의 타입 오류를 검사한다.
     -> 바벨과의 다른 점: 바벨은 타입 검사를 하지 않는다.

- 타입스크립트의 컴파일 과정
  1. tsc 명령어를 실행하여 프로그램 객체가 컴파일 과정을 시작한다.
  2. 스캐너는 소스 파일을 토큰 단위로 분리한다.
  3. 파서는 토큰을 이용하여 AST를 생성한다.
  4. 바인더는 AST의 각 노드에 대응하는 심볼을 생성한다. 심볼은 선언된 타입의 노드 정보를 담고 있다.
  5. 체커는 AST를 탐색하면서 심볼 정보를 활용하여 타입 검사를 수행한다.
  6. 타입 검사 결과 에러가 없다면 이미터를 사용해서 자바스크립트 소스 파일로 변환한다.

## 7. 비동기 호출

### 7.1 API 요청

- API 응답이 바뀌었을 때는 클라이언트 코드를 수정하는 데 들어가는 비용을 줄이면서도 도메인의 일관성을 지킬 수 있는 절충안을 찾아야 한다.
- 절충안
  - 꼭 필요한 곳에만 뷰 모델을 부분적으로 만들어서 사용하기
  - 백엔드와 클라이언트 개발자가 충분히 소통한 다음에 개발하여 API 응답 변화를 최대한 줄이기
  - 뷰 모델에 필드를 추가하는 대신에 getter 등의 함수를 추가하여 실제 어떤 값이 뷰 모델에 추가한 값인지 알기 쉽게 하기

### 7.2 API 상태 관리하기

- 상태 관리 라이브러리에서 호출(Redux, MobX)
- 훅으로 호출(react-query, useSwr)

### 7.3 API 에러 핸들링

- 타입 가드 활용하기
- 에러 서브클래싱하기
- 인터셉터를 활용한 에러 처리
- 에러 바운더리를 활용한 에러 처리
- 상태 관리 라이브러리에서의 에러 처리
- react-query를 활용한 에러 처리
- 그 밖의 에러 처리

### 7.4 API 모킹

- JSON 파일 불러오기
- NextApiHandler 활용하기
- API 요청 핸들러에 분기 추가하기
- axios-mock-adapter로 모킹하기
- 목업 사용 여부 제어하기

## 질문

1. never 타입은 자바스크립트에서 값을 반환할 수 없는 경우에 사용하는데, 어떤 경우인지 2가지를 예시로 알려주세요.
   <details>
   <summary>정답</summary>
   1. 에러를 던지는 경우 <code>throw new Error()</code>
   <br/>
   2. 무한히 함수가 실행되는 경우 <code>while(true) {//}</code>
   </details>

2. 제네릭을 사용할 때 주의할 점과 해결 방법에 대해서 설명해주세요.
   <details>
   <summary>정답</summary>
   - 주의할 점: 파일 확장자가 tsx일 때 화살표 함수에 제네릭을 사용하면 에러가 발생. 이유는 제네릭의 꺾쇠 괄호와 태그의 꺾쇠 괄호를 혼동하여 문제가 발생하는 것.
   <br/>
   - 해결 방법:
    <br/>
      1. 제네릭 부분에 extends 키워드를 사용하여 컴파일러에게 특정 타입의 하위 타입만 올 수 있음을 확실히 알려준다. <code>&#60T extends {}></code>
      <br/>
      2. function 키워드를 사용한다.
   </details>

3. 타입 가드는 무엇이며, 사용하는 이유는 무엇인가?
   <details>
   <summary>정답</summary>
   - 타입 가드란, 타입을 좁히는 방법 중의 하나로, 타입 좁히기란 변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정을 말한다.
   <br/>
   - 사용 목적: 특정 문맥 안에서 타입스크립트가 해당 변수를 특정 타입으로 추론하도록 유도하면서 런타임에서도 유효한 방법이 필요하다. 이때 활용할 수 있다.
   </details>

4. 다음 중 옳은 식별할 수 있는 유니온의 판별자는?

   ```typescript
   type test1 = {
     errorType: boolean; // (O/X)
     errorCode: string;
     errorMessage: string;
   };
   type test2 = {
     errorType: true; // (O/X)
     errorCode: string;
     errorMessage: string;
   };
   ```

   <details>
   <summary>정답</summary>
   1. X
   <br/>
   2. O
   </details>

5. 아래 코드를 설명해주세요.

   ```typescript
   type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
   ```

   <details>
   <summary>정답</summary>
   - UnpackPromise 타입은 제네릭으로 T를 받아 T가 Promise로 래핑된 경우라면 K를 반환하고, 그렇지 않은 경우에는 any를 반환한다.
   <br/>
   - `Promise&#60infer K>`는 Promise의 반환 값을 추론해 해당 값의 타입을 K로 한다는 의미이다.
   </details>

6. 타입스크립트 코드 타이핑이 잘못되어 발생하는 에러는 런타임 에러로 처리된다. (O/X)

   <details>
   <summary>정답</summary>
   - O
   <br/>
   - 타입스크립트의 컴파일러는 타입 검사를 수행한 후, 코드 변환을 시작하는데, 이때 타입 오류가 있더라도 일단 컴파일을 진행한다.
   <br/>
   - 타입스크립트 코드가 자바스크립트 코드로 변환되는 과정은 타입 검사와 독립적으로 동작하기 때문이다.
   </details>

7. tsc와 바벨은 비슷한 역할을 한다. 그 역할은 무엇이며, 차이는 무엇인가?

   <details>
   <summary>정답</summary>
   - 역할: 최신 버전의 자바스크립트 코드를 구버전의 자바스크립트 코드로 트랜스 파일한다.
   <br/>
   - 차이: 바벨은 타입 검사를 하지 않는다.
   </details>
